#!/usr/bin/python3 -S

import os
import sys
import time

def bold(s: str) -> str:
    return '\033[37;1m' + s + '\033[m'  #]]

def green(s: str) -> str:
    return '\033[32m' + s + '\033[m'  #]]

def read_fd(fd: int) -> str:
    return os.pread(fd, 4096, 0).strip().decode()

def read_file(path: str) -> str:
    try:
        fd = os.open(path, 0)
    except FileNotFoundError:
        return 'N/A'
    try:
        return read_fd(fd)
    finally:
        os.close(fd)

def align_fields(fields: list[str], align: list[int], sep: str) -> str:
    return sep.join([f'{x:{a}}' for x, a in zip(fields, align)])

def wrap_deduct_green(words: list[str], width: int) -> list[str]:
    line: list[str] = []
    line_w = 0
    lines: list[str] = []
    for word in words:
        w = len(word)
        if '\033' in word:
            w -= len(green(''))
        if line_w + w > width:
            lines.append(' '.join(line))
            line = []; line_w = 0
        line.append(word)
        line_w += w + 1

    lines.append(' '.join(line))
    return lines

class Bundle:
    __slots__ = ('items', 'seen')
    def __init__(self) -> None:
        self.items: list[str] = []
        self.seen: set[str] = set()

    def items_unique_marked(self) -> str:
        if len(self.seen) == 1:
            unique_seen = self.seen.copy().pop()
            return ' '.join(
                [f'[{green(x)}]' if x == unique_seen else x for x in self.items])
        else:
            return ' '.join(self.items)

# =============================================================================

OUT = sys.stdout

TITLE_INDENT = 2
SEP          = '  '
CPU_PATH     = '/sys/devices/system/cpu'
CPU_INTEL_PSTATE_PATH = CPU_PATH + '/intel_pstate'
CPU_IDLE_PATH         = CPU_PATH + '/cpuidle'
ACPI_PATH    = '/sys/firmware/acpi'

def make_title(s: str) -> str:
    return bold(f'{TITLE_INDENT * "="}> {s}')

def write_cpu_intel_pstate() -> None:
    if not os.path.exists(CPU_INTEL_PSTATE_PATH):
        return

    hwp_dynboost =     read_file(CPU_INTEL_PSTATE_PATH + '/hwp_dynamic_boost')
    max_pct      =     read_file(CPU_INTEL_PSTATE_PATH + '/max_perf_pct')
    min_pct      =     read_file(CPU_INTEL_PSTATE_PATH + '/min_perf_pct')
    no_turbo     = int(read_file(CPU_INTEL_PSTATE_PATH + '/no_turbo'))
    turbo        = str(int(not no_turbo))
    status       =     read_file(CPU_INTEL_PSTATE_PATH + '/status')
    perf_range   = f'{min_pct} - {max_pct}'

    intel_header = ['HWP DYN. BOOST', 'MIN/MAX PERF %', 'TURBO', 'STATUS']
    intel_align = [len(x) for x in intel_header]
    intel = [hwp_dynboost, perf_range, turbo, status]
    for i, x in enumerate(intel):
        intel_align[i] = max(intel_align[i], len(x))

    title  = make_title(CPU_INTEL_PSTATE_PATH)
    header = align_fields(intel_header, intel_align, SEP)
    row    = align_fields(intel, intel_align, SEP)

    OUT.write(title + '\n')
    OUT.write(header + '\n')
    OUT.write(row + '\n')

def write_cpu_idle() -> None:
    if not os.path.exists(CPU_IDLE_PATH):
        return

    governors = Bundle()
    governors.seen.add(read_file(CPU_IDLE_PATH + '/current_governor_ro'))
    governors.items  = read_file(CPU_IDLE_PATH + '/available_governors').split()
    driver           = read_file(CPU_IDLE_PATH + '/current_driver')

    title = make_title(CPU_IDLE_PATH)
    governors.items_unique_marked()

    OUT.write(title + '\n')
    OUT.write(f'GOVERNORS = {governors.items_unique_marked()}\n')
    OUT.write(f'DRIVER    = {driver}\n')

def write_cpu_generic(nr_cpus: int) -> None:
    amd = os.path.exists(CPU_PATH + '/amd_pstate')
    governors = Bundle()
    epps = Bundle()

    rows: list[list[str]] = []
    rows_header = ['CPU', 'GOVERNOR', 'CPU MHz', 'SCALING MHz']
    if amd:
        rows_header.extend(['BOOST', 'PREFCORE', 'RANK'])
    rows_header.extend(['EPP', 'EPB'])
    rows_align = [len(x) for x in rows_header]

    PREFCORE_RANK_ROW_IDX = len(rows_header) - 3
    prefcore_ranks = []

    for i in range(nr_cpus):
        this_cpufreq  = f'{CPU_PATH}/cpu{i}/cpufreq/'
        this_power    = f'{CPU_PATH}/cpu{i}/power/'

        governor      =     read_file(this_cpufreq + 'scaling_governor')
        scaling_min   = int(read_file(this_cpufreq + 'scaling_min_freq')) // 1000
        scaling_max   = int(read_file(this_cpufreq + 'scaling_max_freq')) // 1000
        cpuinfo_min   = int(read_file(this_cpufreq + 'cpuinfo_min_freq')) // 1000
        cpuinfo_max   = int(read_file(this_cpufreq + 'cpuinfo_max_freq')) // 1000
        epp           =     read_file(this_cpufreq + 'energy_performance_preference')
        epb           =     read_file(this_power   + 'energy_perf_bias')
        cpu           = str(i)
        cpu_range     = f'{cpuinfo_min:>4} - {cpuinfo_max:<4}'
        scaling_range = f'{scaling_min:>4} - {scaling_max:<4}'

        row = [cpu, governor, cpu_range, scaling_range]
        if amd:
            boost         = read_file(this_cpufreq + 'boost')
            prefcore      = read_file(this_cpufreq + 'amd_pstate_hw_prefcore')
            prefcore_rank = read_file(this_cpufreq + 'amd_pstate_prefcore_ranking')
            prefcore_ranks.append(int(prefcore_rank))
            row.extend([boost, prefcore, prefcore_rank])
        row.extend([epp, epb])

        for i, x in enumerate(row):
            rows_align[i] = max(rows_align[i], len(x))
        rows.append(row)

        governors.seen.add(governor)
        epps.seen.add(epp)

    if amd:
        table = {}
        last = prefcore_ranks[0]; rank = 1
        for k in sorted(prefcore_ranks, reverse=True):
            if k != last:
                last = k; rank += 1
            table[k] = str(rank)
        for i, row in enumerate(rows):
            rows[i][PREFCORE_RANK_ROW_IDX] = table[int(row[PREFCORE_RANK_ROW_IDX])]

    governors.items = \
        read_file(f'{CPU_PATH}/cpu0/cpufreq/scaling_available_governors').split()
    epps.items = \
        read_file(f'{CPU_PATH}/cpu0/cpufreq/energy_performance_available_preferences').split()

    title  = make_title(CPU_PATH)
    header = align_fields(rows_header, rows_align, SEP)
    width  = len(header)

    OUT.write(title + '\n')
    OUT.write(header + '\n')
    for r in rows:
        OUT.write(align_fields(r, rows_align, SEP) + '\n')
    OUT.write('\n')

    indent = 9
    OUT.write(f'{"GOVERNORS":{indent}} = {governors.items_unique_marked()}\n')
    OUT.write(f'{"EPPS":{indent}} = ')

    indent_str = (indent + 3) * ' '
    epp_lines = wrap_deduct_green(
        epps.items_unique_marked().split(), width - len(indent_str))
    for i, l in enumerate(epp_lines):
        OUT.write((i > 0) * indent_str + l + '\n')

def write_acpi_profiles() -> None:
    if not os.path.exists(ACPI_PATH):
        return

    profiles = Bundle()
    profiles.items = read_file(ACPI_PATH + '/platform_profile_choices').split()
    profiles.seen.add(read_file(ACPI_PATH + '/platform_profile'))
    title = make_title(ACPI_PATH)

    OUT.write(title + '\n')
    OUT.write(f'PROFILES = {profiles.items_unique_marked()}\n')

def monitor_cpu_freq(
        nr_cpus: int,
        interval_ms: int,
        fallback_mhz: int,
        avg_win_size: int
) -> None:
    assert avg_win_size > 0 and avg_win_size & (avg_win_size - 1) == 0

    cpu_fds = []
    for i in range(nr_cpus):
        path = f'{CPU_PATH}/cpu{i}/cpufreq/scaling_cur_freq'
        cpu_fds.append(os.open(path, 0))
        OUT.write(f'{"CPU" + str(i):6}')
    for e in 'AVG' + str(avg_win_size), 'MIN', 'MAX':
        OUT.write(f'{e:6}')
    OUT.write('\n')

    interval_sec = interval_ms / 1000
    freq_min = 1000 * 1000
    freq_max = 0

    avg_win_mask = avg_win_size - 1
    avg_win = [0] * avg_win_size
    i = 0

    while True:
        s = ''
        t = 0
        for f in [read_fd(fd) for fd in cpu_fds]:
            mhz = int(f) // 1000
            if   mhz < freq_min: freq_min = mhz
            elif mhz > freq_max: freq_max = mhz
            if mhz == fallback_mhz:
                s += '.     '
            else:
                s += f'{mhz:<6}'
            t += mhz

        avg_win[i] = t // nr_cpus
        i = (i + 1) & avg_win_mask

        tw = 0
        for j in range(avg_win_size):
            tw += avg_win[(i + j) & avg_win_mask] << j
        freq_avg = tw // ((1 << avg_win_size) - 1)

        OUT.write(f'{s}~{freq_avg:<4} >{freq_min:<4} <{freq_max:<4}\n')
        time.sleep(interval_sec)

def usage() -> int:
    OUT.write(
        f'usage: {os.path.basename(sys.argv[0])} [[--fallback-mhz=800] <interval_ms>]\n'
        '  --fallback-mhz    After the CPU is idle for 20ms the kernel decides against\n'
        '                    sending an IPI to query current CPU frequency and instead\n'
        '                    retrieves a cpufreq driver-dependent per-CPU policy value\n'
        '                    as fallback. This is a good indication the CPU is idling.\n'
        '                    Set this option to the apparent fallback value -- usually\n'
        '                    the lowest P-State frequency -- to visually differentiate\n'
        '                    potential fallback values from actual frequency readouts.\n'
    )
    return 2

def main() -> int:
    interval_ms = 0
    fallback_mhz = 800
    if len(sys.argv) > 1:
        get_fallback_mhz = False
        for arg in sys.argv[1:]:
            arg, _, value = arg.partition('=')
            if get_fallback_mhz:
                get_fallback_mhz = False
                if arg.isdecimal():
                    fallback_mhz = int(arg)
                    continue
                return usage()

            if arg == '-h' or arg == '--help':
                return usage()
            elif arg == '--fallback-mhz':
                if value.isdecimal():
                    fallback_mhz = int(value)
                else:
                    get_fallback_mhz = True
            elif arg.isdecimal():
                if not interval_ms:
                    interval_ms = int(arg)

    nr_cpus = os.sysconf('SC_NPROCESSORS_ONLN')

    write_cpu_intel_pstate()
    write_cpu_generic(nr_cpus)
    write_cpu_idle()
    write_acpi_profiles()
    if interval_ms:
        monitor_cpu_freq(nr_cpus, interval_ms, fallback_mhz, 8)

    return 0

if __name__ == '__main__':
    try:
        raise SystemExit(main())
    except KeyboardInterrupt:
        OUT.write('\n')
