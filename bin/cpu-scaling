#!/usr/bin/python3 -S

import os
import sys
import time

def bold(s: str) -> str:
    return '\033[37;1m' + s + '\033[m'  #]]

def gray(s: str) -> str:
    return '\033[90m' + s + '\033[m'  #]]

def green(s: str) -> str:
    return '\033[32m' + s + '\033[m'  #]]

def read_fd(fd: int) -> str:
    return os.pread(fd, 4096, 0).strip().decode()

def read_file(path: str) -> str:
    try:
        fd = os.open(path, os.O_RDONLY)
    except FileNotFoundError:
        return 'N/A'
    try:
        return read_fd(fd)
    finally:
        os.close(fd)

def align_fields(fields: list[str], align: list[int], sep: str) -> str:
    return sep.join([f'{x:{a}}' for x, a in zip(fields, align)])

class Bundle:
    __slots__ = ('items', 'seen')
    def __init__(self) -> None:
        self.items: list[str] = []
        self.seen: set[str] = set()

    def items_unique_marked(self) -> str:
        if len(self.seen) == 1:
            unique_seen = self.seen.copy().pop()
            return ' '.join(
                [f'[{green(x)}]' if x == unique_seen else x for x in self.items])
        else:
            return ' '.join(self.items)

# =============================================================================

TITLE_INDENT = 2
SEP          = '  '
CPU_PATH     = '/sys/devices/system/cpu'
CPU_INTEL_PSTATE_PATH = CPU_PATH + '/intel_pstate'
ACPI_PATH    = '/sys/firmware/acpi'
CGROUP_PATH  = '/sys/fs/cgroup'

def make_title(s: str) -> str:
    return bold(f'{TITLE_INDENT * "="}> {s}')

def read_nr_cpus() -> int:
    return int(read_file(CPU_PATH + '/present').rpartition('-')[2]) + 1

def write_cpu_intel_pstate() -> None:
    if not os.path.exists(CPU_INTEL_PSTATE_PATH):
        return

    hwp_dynboost =     read_file(CPU_INTEL_PSTATE_PATH + '/hwp_dynamic_boost')
    max_pct      =     read_file(CPU_INTEL_PSTATE_PATH + '/max_perf_pct')
    min_pct      =     read_file(CPU_INTEL_PSTATE_PATH + '/min_perf_pct')
    no_turbo     = int(read_file(CPU_INTEL_PSTATE_PATH + '/no_turbo'))
    turbo        = str(int(not no_turbo))
    status       =     read_file(CPU_INTEL_PSTATE_PATH + '/status')
    perf_range   = f'{min_pct} - {max_pct}'

    intel_header = ['HWP DYN. BOOST', 'MIN/MAX PERF %', 'TURBO', 'STATUS']
    intel_align = [len(x) for x in intel_header]
    intel = [hwp_dynboost, perf_range, turbo, status]
    for i, x in enumerate(intel):
        intel_align[i] = max(intel_align[i], len(x))

    title  = make_title(CPU_INTEL_PSTATE_PATH)
    header = align_fields(intel_header, intel_align, SEP)
    row    = align_fields(intel, intel_align, SEP)

    o = sys.stdout
    o.write(title + '\n')
    o.write(header + '\n')
    o.write(row + '\n')

def write_cpu_generic(nr_cpus: int) -> None:
    governors = Bundle()
    epps = Bundle()

    rows: list[list[str]] = []
    rows_header = ['CPU', 'GOVERNOR', 'CPU MHz', 'SCALING MHz', 'EPP', 'EPB']
    rows_align = [len(x) for x in rows_header]

    for i in range(nr_cpus):
        this_cpufreq  = f'{CPU_PATH}/cpu{i}/cpufreq/'
        this_power    = f'{CPU_PATH}/cpu{i}/power/'

        governor      =     read_file(this_cpufreq + 'scaling_governor')
        scaling_min   = int(read_file(this_cpufreq + 'scaling_min_freq')) // 1000
        scaling_max   = int(read_file(this_cpufreq + 'scaling_max_freq')) // 1000
        cpuinfo_min   = int(read_file(this_cpufreq + 'cpuinfo_min_freq')) // 1000
        cpuinfo_max   = int(read_file(this_cpufreq + 'cpuinfo_max_freq')) // 1000
        epp           =     read_file(this_cpufreq + 'energy_performance_preference')
        epb           =     read_file(this_power   + 'energy_perf_bias')
        cpu           = str(i)
        cpu_range     = f'{cpuinfo_min:>4} - {cpuinfo_max:<4}'
        scaling_range = f'{scaling_min:>4} - {scaling_max:<4}'

        row = [cpu, governor, cpu_range, scaling_range, epp, epb]
        for i, x in enumerate(row):
            rows_align[i] = max(rows_align[i], len(x))
        rows.append(row)

        governors.seen.add(governor)
        epps.seen.add(epp)

    governors.items = \
        read_file(f'{CPU_PATH}/cpu0/cpufreq/scaling_available_governors').split()
    epps.items = \
        read_file(f'{CPU_PATH}/cpu0/cpufreq/energy_performance_available_preferences').split()

    title  = make_title(CPU_PATH)
    header = align_fields(rows_header, rows_align, SEP)
    width  = len(header)

    o = sys.stdout
    o.write(title + '\n')
    o.write(header + '\n')
    for r in rows:
        o.write(align_fields(r, rows_align, SEP) + '\n')
    o.write('\n')

    extra_indent = 9
    line: list[str] = []
    line_w = 0
    lines: list[str] = []
    for item in epps.items_unique_marked().split():
        w = len(item)
        if '\033' in item:
            w -= len(green(''))
        if line_w + w > width - extra_indent - 3:
            lines.append(' '.join(line))
            line = [item]
            line_w = 0
        else:
            line.append(item)
        line_w += w + 1
    lines.append(' '.join(line))

    o.write(f'{"GOVERNORS":{extra_indent}} = {governors.items_unique_marked()}\n')
    o.write(f'{"EPPS":{extra_indent}} = ')
    for i, l in enumerate(lines):
        o.write((i * (extra_indent + 3)) * ' ' + l + '\n')

def write_acpi_profiles() -> None:
    if not os.path.exists(ACPI_PATH):
        return

    profiles = Bundle()
    profiles.items = read_file(ACPI_PATH + '/platform_profile_choices').split()
    profiles.seen.add(read_file(ACPI_PATH + '/platform_profile'))
    title = make_title(ACPI_PATH)

    o = sys.stdout
    o.write(title + '\n')
    o.write(f'PROFILES = {profiles.items_unique_marked()}\n')

def write_cgroup_cpuset() -> None:
    if not os.path.exists(CGROUP_PATH):
        return

    files = os.listdir(CGROUP_PATH)

    rows: list[list[str]] = []
    rows_header = ['CGROUP', 'WEIGHT', 'NICE', 'CPUS', 'EFFECTIVE']
    rows_align = [len(x) for x in rows_header]

    for file in files:
        this_cgroup = f'{CGROUP_PATH}/{file}'
        if os.path.isdir(this_cgroup):
            weight    = read_file(this_cgroup + '/cpu.weight')
            nice      = read_file(this_cgroup + '/cpu.weight.nice')
            cpus      = read_file(this_cgroup + '/cpuset.cpus')
            effective = read_file(this_cgroup + '/cpuset.cpus.effective')

            row = [file, weight, nice, cpus, effective]
            for i, x in enumerate(row):
                rows_align[i] = max(rows_align[i], len(x))
            rows.append(row)

    title  = make_title(CGROUP_PATH)
    header = align_fields(rows_header, rows_align, SEP)

    o = sys.stdout
    o.write(title + '\n')
    o.write(header + '\n')
    for cgroup, weight, nice, cpus, effective in rows:
        row = align_fields(
            [cgroup, weight, nice, cpus, effective], rows_align, SEP)
        if cgroup.endswith('.mount'):
            row = gray(row)
        o.write(row + '\n')

def monitor_cpu_freq(nr_cpus: int, interval_ms: int, fallback_mhz: int) -> None:
    cpu_fds = []

    o = sys.stdout
    for i in range(nr_cpus):
        path = f'{CPU_PATH}/cpu{i}/cpufreq/scaling_cur_freq'
        cpu_fds.append(os.open(path, os.O_RDONLY))
        o.write(f'CPU{i:<5}')
    o.write('\n')

    interval_sec = interval_ms / 1000
    freq_min = 1000 * 1000
    freq_max = 0

    while True:
        s = ''
        for f in [read_fd(fd) for fd in cpu_fds]:
            mhz = int(f) // 1000
            if mhz > freq_max:
                freq_max = mhz
            elif mhz < freq_min:
                freq_min = mhz
            elif mhz == fallback_mhz:
                s += '.       '
                continue
            s += f'{mhz:<8}'

        o.write(f'{s}>{freq_min:<4} <{freq_max:<4}\n')
        time.sleep(interval_sec)

def usage() -> int:
    o = sys.stdout
    o.write(
        f'usage: {os.path.basename(sys.argv[0])} [[--fallback-mhz=800] <interval_ms>]\n'
        '  --fallback-mhz    After the CPU is idle for 20ms the kernel decides against\n'
        '                    sending an IPI to query current CPU frequency and instead\n'
        '                    retrieves a cpufreq driver-dependent per-CPU policy value\n'
        '                    as fallback. This is a good indication the CPU is idling.\n'
        '                    Set this option to the apparent fallback value -- usually\n'
        '                    the lowest P-State frequency -- to visually differentiate\n'
        '                    potential fallback values from actual frequency readouts.\n'
    )
    return 2

def main() -> int:
    interval_ms = 0
    fallback_mhz = 800
    if len(sys.argv) > 1:
        get_fallback_mhz = False
        for arg in sys.argv[1:]:
            arg, _, value = arg.partition('=')
            if get_fallback_mhz:
                get_fallback_mhz = False
                if arg.isdecimal():
                    fallback_mhz = int(arg)
                    continue
                return usage()

            if arg == '-h' or arg == '--help':
                return usage()
            elif arg == '--fallback-mhz':
                if value.isdecimal():
                    fallback_mhz = int(value)
                else:
                    get_fallback_mhz = True
            elif arg.isdecimal():
                if not interval_ms:
                    interval_ms = int(arg)

    nr_cpus = read_nr_cpus()

    write_cpu_intel_pstate()
    write_cpu_generic(nr_cpus)
    write_acpi_profiles()
    write_cgroup_cpuset()
    if interval_ms:
        monitor_cpu_freq(nr_cpus, interval_ms, fallback_mhz)

    return 0

if __name__ == '__main__':
    try:
        raise SystemExit(main())
    except KeyboardInterrupt:
        sys.stdout.write('\n')
